--- NT4\private\mvdm\softpc.new\base\debug\dasm.c
+++ nt\private\mvdm\softpc.new\base\debug\dasm.c
51a52,57
> #if defined(CPU_40_STYLE) && !defined(HOST_SAS)
> #define inc_M_ptr(p,o)	(p+(o))
> #define get_byte_addr(addr) ((IU8 *)((IHPE)Start_of_M_area + (PHY_ADDR)(addr)))
> #define M_get_dw_ptr(address) ((IHPE)Start_of_M_area + (long)(address))
> #endif
> 
--- NT4\private\mvdm\softpc.new\base\debug\yoda.c
+++ nt\private\mvdm\softpc.new\base\debug\yoda.c
19a20,22
> #if !defined(macintosh) && !defined(SFELLOW)
> #include <time.h>
> #endif
1975c1978
< 
---
> #endif /* GISP_CPU */
1991c1994
< #endif /* GISP_CPU */
---
> 
3041a3045,3173
> #ifdef NTVDM
> // leecher1337: DOSX DPMI tracing support 
> LOCAL YODA_COMMAND(do_dpmitr)
> {
> 	static struct {
> 		char *name;
> 		IU16 *addr;
> 		char *descr;
> 	}
> 	 trace_flags[] = 
> 	{
> 	 {"tracedos",     NULL, "Trace DOS calls:\n"
> 		"    Trace levels: 1 - print AX on all calls except 3F, 40, 42 (read, write,\n"
> 		"                      seek--Windows does so many of these...)\n"
> 		"                  2 - like level 1, but includes 3F, 40, 42\n"
> 		"                  3 - print all regs on all calls"
> 	 },
> 	 {"tracefault",   NULL, "Trace faults on MIPS, currently unused"},
> 	 {"tracea20",     NULL, "Make sure that A20 is enabled"},
> 	 {"tracebug",     NULL, "Debug INT 41h Debugger interface"},
> 	 {"trapdos",      NULL, "Trap DOS calls"},
> 	 {"tableslow",    NULL, "unused"},
> 	 {"tracereflect", NULL, "Trace Interrupt reflector:\n"
> 		"    Trace levels: 1 - Trace all Interrupt reflector calls\n"
> 		"                  2 - Also trace call ends\n"
> 		"                  3 - Also trace Reflector stack location"
> 	 },
> 	 {"tracemode",    NULL, "Trace Real/Protectedmode switches"}
> 	};
> 	int n, n_found, negate;
> 	IU16 mask;
> 	char *flag_name, *flag_val;
> 
> 	UNUSED(com);
> 	UNUSED(cs);
> 	UNUSED(ip);
> 	UNUSED(len);
> 	UNUSED(stop);
> 
> 	/*
> 	 * Collect offsets of DOSX trace flags
> 	 */
> 	if (!trace_flags[0].addr)
> 	{
> 		LIN_ADDR lin = effective_addr(0x0F00, 0);
> 		IU8 *pDOSXDS = getPtrToLinAddrByte(lin);
> 		int i, j;
> 
> 		if (pDOSXDS)
> 		{ 
> 			for (i=0; i<0x4000; i++)
> 			{
> 				if (pDOSXDS[0] == 't' && strncmp(pDOSXDS, "tracedos", 8) == 0)
> 				{
> 					// Assuming these are in order, no searching
> 					for (j=0; *pDOSXDS && j<sizeof(trace_flags)/sizeof(trace_flags[0]); j++)
> 					{
> 						if (!strcmp(trace_flags[j].name, pDOSXDS))
> 						{
> 							pDOSXDS += strlen(pDOSXDS) + 1;
> 							trace_flags[j].addr = (IU16*)pDOSXDS;
> 							pDOSXDS += sizeof(IU16);
> 						}
> 					}
> 					break;
> 				}
> 				pDOSXDS++;
> 			}
> 		}
> 		if (!trace_flags[sizeof(trace_flags)/sizeof(trace_flags[0])-1].addr)
> 		{
> 			printf ("DOSX trace flags not found I have, sure running a DEBUG build of DOSX you are?\n");
> 			return (YODA_LOOP);
> 		}
> 	}
> 
> 	/*
> 	 * strip off command and get first flag name
> 	 */
> 	n_found = 0;
> 	(void) strtok (str, " \t");
> 
> 	if (flag_name = strtok(NULL, " \t")) {
> 		/*
> 		 * Pick out symbolic flag name and see whether is is being set
> 		 * or reset.
> 	 	 */
> 		n_found += 1;
> 		negate = (flag_name[0] == '-');
> 		if (negate)
> 		{
> 			flag_name += 1;
> 			mask = 0;
> 		}
> 		else
> 		{		
> 			if (flag_val = strtok(NULL, " \t"))
> 				mask = (IU16)atoi(flag_val);
> 			else
> 				mask = 1;
> 		}
> 
> 		/*
> 	 	 * Find flag and twiddle bits as appropriate.
> 	 	 */
> 		for (n = 0; n < sizeof(trace_flags)/sizeof(trace_flags[0]); n++)
> 			if (!strcmp(flag_name, trace_flags[n].name) && trace_flags[n].addr) {
> 				*trace_flags[n].addr = mask;
> 				break;
> 			}
> 	}
> 
> 	/*
> 	 * Print current trace flags if no recognised flags passed in command.
> 	 * (or empty command line).
> 	 */
> 	if (n_found == 0) {
> 		for (n = 0; n < sizeof(trace_flags)/sizeof(trace_flags[0]); n++) {
> 			printf ("%-14s: %d\t%s\n", trace_flags[n].name,
> 				trace_flags[n].addr ? *trace_flags[n].addr : 0,
> 				trace_flags[n].descr);
> 		}
> 		printf ("\n\n");
> 	}
> 
> 	return(YODA_LOOP);
> }
> #endif
> 
4912a5045,5047
> #ifdef NTVDM
> { "dpmitr",	do_dpmitr,FALSE, NULL, "Toggle DOSX Dpmi tracing, if DOSX debug build" },
> #endif
5015a5151
> #endif	/* GISP_CPU */
5018d5153
< #endif	/* GISP_CPU */
--- NT4\private\mvdm\softpc.new\host\src\fprt.c
+++ nt\private\mvdm\softpc.new\host\src\fprt.c
148a149
> 	int len;
150c151
<     if (getenv("TRACE") == NULL)        //JonLu request to limit debugs
---
>     if (getenv("TRACE") == NULL && tf==stdout)        //JonLu request to limit debugs
154c155
<     vsprintf(buf, str, ap);
---
>     len = vsprintf(buf, str, ap);
156c157
<     OutputString(buf);
---
>     fwrite(buf,len,1,tf);
226a229,234
>     if(stream != stdout)
>     {
> 	int i;
> 	for (i=0; i<size*len && (fputc(((unsigned char*)buf)[i], stream)) != EOF; i++);
> 	return (len);
>     }
227c236
<     tmp_buf[len] = 0;		// write into a const ptr!
---
>     if (tmp_buf[size*len]) tmp_buf[size*len] = 0;		// Bullshit write into a const ptr!
--- NT4\private\mvdm\softpc.new\base\comms\com.c
+++ nt\private\mvdm\softpc.new\base\comms\com.c
61a62
> extern FILE *in_stream;
287c289
< FILE     *com_trace_fd = NULL;
---
> FILE     *com_trace_fd = NULL, *com_trace_rawfd = NULL;
802a805
> 				if (com_trace_rawfd) fwrite(&value, 1, 1, com_trace_rawfd); 
3844a3848,3850
> 	if (com_trace_rawfd)
> 		fclose (com_trace_rawfd);
> 	com_trace_rawfd = NULL;
4023a4030,4036
> static int yscanf(char *format, void *arg)
> {
> 	char str [81];
> 	if (fgets (str, 80, in_stream))
> 		return sscanf(str, format, arg);
> 	return 0;
> }
4032c4045
< 	scanf ("%s", ref);
---
> 	yscanf ("%s", ref);
4134c4147
< 		scanf ("%x", &val1);
---
> 		yscanf ("%x", &val1);
4172c4185
< 	scanf ("%s", com_reg);
---
> 	yscanf ("%s", com_reg);
4190c4203
< 	scanf ("%s", com_reg);
---
> 	yscanf ("%s", com_reg);
4197c4210
< 	scanf ("%x", &val);
---
> 	yscanf ("%x", &val);
4211c4224
< 	scanf ("%s", filename);
---
> 	yscanf ("%s", filename);
4276c4289
< 	scanf ("%s", filename);
---
> 	yscanf ("%s", filename);
4303c4316,4328
< 
---
> int com_o_rawfd ()
> {
> 	char filename[100];
> 	printf ("FILE > ");
> 	yscanf ("%s", filename);
> 	if (!(com_trace_rawfd = fopen (filename, "w")))
> 	{
> 		printf ("Cannot open %s\n", filename);
> 		return (0);
> 	}
> 	printf ("Com raw debug output file = '%s'\n", filename);
> 	return (0);
> }
4444a4470
> 	{"rawo",   com_o_rawfd,      "  Open raw output logfile"},
