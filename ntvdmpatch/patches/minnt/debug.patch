--- NT4\private\mvdm\softpc.new\base\debug\trace.c
+++ nt\private\mvdm\softpc.new\base\debug\trace.c
493a496,497
> 
>  /* No YODA in i386, so let use set this via env too */
>  start = host_getenv("SUB_IO_VERBOSE");
>  if (start) sub_io_verbose = atoi(start);
> 
>  start = host_getenv("IO_VERBOSE");
>  if (start) io_verbose = atoi(start);
> 
--- NT4\private\mvdm\softpc.new\base\support\main.c
+++ nt\private\mvdm\softpc.new\base\support\main.c
183c183
<   io_verbose = FALSE;
---
>   //io_verbose = FALSE;  // Already set in trace_init() and is initialized with 0 globally anway
--- NT4\private\mvdm\softpc.new\host\src\nt_bop.c
+++ nt\private\mvdm\softpc.new\host\src\nt_bop.c
13a14
> #include <dbgsvc.h>
328a330,353
> #ifdef YODA
>     UNALIGNED WORD  *stack;
>     char *p;
>     
>     stack = (UNALIGNED WORD *)Sim32GetVDMPointer(
>                         ((ULONG)getSS() << 16) + (ULONG)getSP(),
>                         MAX_DBG_FRAME, (getMSW() & MSW_PE ? 1 : 0));
>                         
>     // Resembles WDEB386 API, may become handy some day...
>     if (stack && (*stack & 0x4100) == 0x4100)
>     {
>         switch (*stack++)
>         {
>             case DBG_OUTCHAR:
>                 printf("%c", (*stack & 0xFF));
>                 break;
>             case DBG_OUTSTR:
>                 p = Sim32GetVDMPointer(((ULONG)stack[0] << 16) + (ULONG)stack[1],
>                     256, (getMSW() & MSW_PE ? 1 : 0));
>                 if (p) printf("%s", p);
>                 break;
>         }
>     }      
> #endif
754a780
> #ifdef X86GFX
762a789
> #endif
