/* Project: ldntvdm
 * Module : codegen
 * Author : leecher@dose.0wnz.at
 * Descr. : Creates assembler code to embed into loader for injection routines.
 *          This has to be done this way in order to have good code maintainability 
 *          of the routines (can write them in C once instead of writing 2 versions
 *          for x86 and x64 in ASM), as we need shell code for 32- and 64bit in 
 *          both loaders.
 * Changes: 11.09.2021  - Created
 */

#define WIN32_LEAN_AND_MEAN
#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <winternl.h>
#include <stdio.h>
#include "../ldntvdm/injector.h"

// Set this if you want to dump directly, otherwise given .cod file will be dumped (recommended)
// #define DUMP_DIRECT

#ifdef DUMP_DIRECT
#ifdef _WIN64
#pragma comment(lib, "..\\ldntvdm\\LDE64x64")
size_t __fastcall LDE(const LPVOID lpData, unsigned int size);
#else
#pragma comment(lib, "..\\ldntvdm\\LDE64")
size_t __stdcall LDE(const LPVOID lpData, unsigned int size);
#endif

#define CODE_SEG(seg) __declspec(code_seg(seg))
#else
#define CODE_SEG(seg) 
#endif  // DUMP_DIRECT

#ifdef _WIN64
#define ARCH "x64"
#else
#define ARCH "x86"
#endif

#define NtCurrentThread() ( (HANDLE)(LONG_PTR) -2 )   // ntddk wdm ntifs

/* The routines that need to be assembled */
static CODE_SEG(".text$1") VOID WINAPI ThreadProc(PTHREAD_DATA data)
{
	data->fnLdrLoadDll(data->DllPath, data->Flags, &data->UnicodeString, &data->ModuleHandle);
	data->fnNtTerminateThread(NtCurrentThread(), 0);
}

static CODE_SEG(".text$2") HANDLE WINAPI APCProc(PTHREAD_DATA data)
{
	data->fnLdrLoadDll(data->DllPath, data->Flags, &data->UnicodeString, &data->ModuleHandle);
	if (data->OrigEIP) return (HANDLE)data->OrigEIP(data->EIPParams);
	return data->ModuleHandle;
}

static CODE_SEG(".text$3")  VOID WINAPI PostProcProc(VOID)
{
	// Workaround for compiler to not generate absolute addresses
	register PTHREAD_DATA pdata = (PTHREAD_DATA)((ULONG_PTR)1 << (sizeof(ULONG_PTR) * 8 - 1));
	PTHREAD_DATA data = (PTHREAD_DATA)pdata->fnLdrLoadDll;

	data->fnLdrLoadDll(data->DllPath, data->Flags, &data->UnicodeString, &data->ModuleHandle);
	if (data->fnOrigPostProcessInit) data->fnOrigPostProcessInit();
}

static CODE_SEG(".text$4") NTSTATUS LdrpInitializeProcessProc(IN PCONTEXT Context OPTIONAL, IN PVOID SystemDllBase)
{
	NTSTATUS Status;
	// Workaround for compiler to not generate absolute addresses
	register PTHREAD_DATA pdata = (PTHREAD_DATA)((ULONG_PTR)1 << (sizeof(ULONG_PTR) * 8 - 1));
	PTHREAD_DATA data = (PTHREAD_DATA)pdata->fnLdrLoadDll;

	Status = data->fnLdrpInitializeProcess(Context, SystemDllBase);
	if (NT_SUCCESS(Status))
		data->fnLdrLoadDll(data->DllPath, data->Flags, &data->UnicodeString, &data->ModuleHandle);
	return Status;
}

#ifdef DUMP_DIRECT
#define DUMP_FUNCTION(func) dumpFunction(fpOut, func, #func##ARCH)

// dump function from memory
static void dumpFunction(FILE *fp, LPBYTE lpRoutine, const char *pszName)
{
	SIZE_T i = 0, j, Len;

	fprintf(fp, "BYTE %s[] = {", pszName);
	while (i < 0x1000)
	{
		Len = LDE(&lpRoutine[i], 64);
		if (Len == 1 && lpRoutine[i] == 0xCC) break;
		if (i) fprintf(fp, ",");
		fprintf(fp, "\n\t");
		for (j = 0; j < Len; j++, i++)
		{
			fprintf(fp, "0x%02X", lpRoutine[i]);
			if (j < Len - 1) fprintf(fp, ", ");
		}
	}
	fprintf(fp, "\n};\n\n");
}

#else // DUMP_DIRECT

#define DUMP_FUNCTION(func) sprintf (szRoutine, "%s%s", #func, pszArch); dumpFunctionFromCodFile(fpOut, fpCOD, (LPBYTE)func, #func, szRoutine)
// Dump function from .cod file generated by the compiler
static void dumpFunctionFromCodFile(FILE *fp, FILE *fpCOD, LPBYTE lpRoutine, const char *pszFunc, const char *pszName)
{
	char szLine[1024], szNextLine[sizeof(szLine)], *pszLine, *p;
	int iLenName = strlen(pszFunc), iRet;
	BOOL fInFunc = FALSE;

	if (lpRoutine[0]!=0)  // Reference function so that it doesn't get optimized out
	fseek(fpCOD, 0, SEEK_SET);
	while (fgets(szLine, sizeof(szLine), fpCOD))
	{
		if (!*szLine ||*szLine=='\n') continue;
		pszLine = szLine;
		if (*pszLine == '_') *pszLine++;
		if (!_strnicmp(pszLine, pszFunc, iLenName))
		{
			pszLine += iLenName;
			if (pszLine = strtok(pszLine, " \t\n"))
			{
				if (p = strtok(NULL, " \t\n")) pszLine = p;
			}
			if (!pszLine) continue;
			if (!_stricmp(pszLine, "ENDP"))
			{
				fprintf(fp, "\n};\nconst unsigned int %sSize = sizeof(%s);\n\n", pszName, pszName);
				break;
			}
			else if (!_stricmp(pszLine, "PROC"))
			{
				fInFunc = TRUE;
				fprintf(fp, "BYTE %s[] = {\n", pszName);
				continue;
			}
		}
		if (fInFunc)
		{
			char *pszOffset, *pszCode, *pszDasm, *p;
			int iEnd, iFill;

			if (*szLine == ';') fprintf(fp, "// %s", szLine + 2);
			else
			{
				pszOffset = *szLine=='\t'?"\t":strtok(szLine, "\t");
				pszCode = strtok(*szLine == '\t'?szLine:NULL, "\t");
				pszDasm = strtok(NULL, "\n");
				fprintf(fp, "/*%-6s */\t", pszOffset+1);

				if (fgets(szNextLine, sizeof(szNextLine), fpCOD))
				{
					iRet = strlen(szNextLine)+1;
					pszLine = szNextLine;
					if (*pszLine == '_') *pszLine++;
					iEnd = _strnicmp(pszLine, pszFunc, iLenName);
					fseek(fpCOD, -iRet, SEEK_CUR);
				}
				else iEnd = 0;

				for (iFill=32, p = strtok(pszCode, " \n"); p; )
				{
					iFill -= fprintf(fp, "0x%s", p);
					p = strtok(NULL, " \n");
					if (iEnd || p) iFill -= fprintf(fp, ", ");
				}
				if (pszDasm)
				{
					while (*pszDasm == '\t' || *pszDasm == ' ') pszDasm++;
					if (iFill > 0) fprintf(fp, "%-*s", iFill, "");
					fprintf(fp, "// %s\n", pszDasm);
				}
				else fprintf(fp, "\n");
			}
		}
	}
}
#endif

int main(int argc, char **argv)
{
	FILE *fpOut = stdout, *fpCOD = NULL;
	char *pszCOD = NULL, szPath[MAX_PATH], *p, *pszArch = ARCH, szRoutine[40];

	if (argc>1 && !(fpOut = fopen(argv[1], "w")))
	{
		perror("Cannot open output file");
		return -1;
	}
#ifndef DUMP_DIRECT
	if (argc < 3)
	{
		GetModuleFileNameA(NULL, szPath, sizeof(szPath));
		if (p = strrchr(szPath, '\\')) p[1] = 0;
		strcat(p, "codegen.cod");
		pszCOD = szPath;
	}
	else pszCOD = argv[2];

	if (argc > 3)
	{
		pszArch = argv[3];
	}

	if (!(fpCOD = fopen(pszCOD, "r")))
	{
		perror("Cannot open .cod file");
		fprintf(stderr, "Usage: %s <Output file> <.cod file>\n", argv[0]);
		if (argc>1) fclose(fpOut);
		return -1;
	}
#endif

	fprintf(fpOut, "// This file has been generated by codegen, do not modify. Instead modify codegen/codegen.c !\n\n");
	DUMP_FUNCTION(ThreadProc);
	DUMP_FUNCTION(APCProc);
	DUMP_FUNCTION(PostProcProc);
	DUMP_FUNCTION(LdrpInitializeProcessProc);

	if (argc>1) fclose(fpOut);
	if (fpCOD) fclose(fpCOD);
	
	return 0;
}