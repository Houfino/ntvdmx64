// This file has been generated by codegen, do not modify. Instead modify codegen/codegen.c !

BYTE ThreadProcx86[] = {
// 46   : {
/* 00000 */	0x55,                           // push	 ebp
/* 00001 */	0x8b, 0xec,                     // mov	 ebp, esp
/* 00003 */	0x56,                           // push	 esi
// 47   : 	data->fnLdrLoadDll(data->DllPath, data->Flags, &data->UnicodeString, &data->ModuleHandle);
/* 00004 */	0x8b, 0x75, 0x08,               // mov	 esi, DWORD PTR _data$[ebp]
/* 00007 */	0x8d, 0x86, 0x28, 0x02, 0x00, 
/*       */	0x00,                           // lea	 eax, DWORD PTR [esi+552]
/* 0000d */	0x50,                           // push	 eax
/* 0000e */	0x8d, 0x46, 0x08,               // lea	 eax, DWORD PTR [esi+8]
/* 00011 */	0x50,                           // push	 eax
/* 00012 */	0xff, 0xb6, 0x1c, 0x02, 0x00, 
/*       */	0x00,                           // push	 DWORD PTR [esi+540]
/* 00018 */	0x8b, 0x06,                     // mov	 eax, DWORD PTR [esi]
/* 0001a */	0xff, 0xb6, 0x18, 0x02, 0x00, 
/*       */	0x00,                           // push	 DWORD PTR [esi+536]
/* 00020 */	0xff, 0xd0,                     // call	 eax
// 48   : 	data->fnNtTerminateThread(NtCurrentThread(), 0);
/* 00022 */	0x8b, 0x46, 0x04,               // mov	 eax, DWORD PTR [esi+4]
/* 00025 */	0x6a, 0x00,                     // push	 0
/* 00027 */	0x6a, 0xfe,                     // push	 -2			; fffffffeH
/* 00029 */	0xff, 0xd0,                     // call	 eax
/* 0002b */	0x5e,                           // pop	 esi
// 49   : }
/* 0002c */	0x5d,                           // pop	 ebp
/* 0002d */	0xc2, 0x04, 0x00                // ret	 4

};
const unsigned int ThreadProcx86Size = sizeof(ThreadProcx86);

BYTE APCProcx86[] = {
// 52   : {
/* 00000 */	0x55,                           // push	 ebp
/* 00001 */	0x8b, 0xec,                     // mov	 ebp, esp
/* 00003 */	0x56,                           // push	 esi
// 53   : 	data->fnLdrLoadDll(data->DllPath, data->Flags, &data->UnicodeString, &data->ModuleHandle);
/* 00004 */	0x8b, 0x75, 0x08,               // mov	 esi, DWORD PTR _data$[ebp]
/* 00007 */	0x57,                           // push	 edi
/* 00008 */	0x8d, 0xbe, 0x28, 0x02, 0x00, 
/*       */	0x00,                           // lea	 edi, DWORD PTR [esi+552]
/* 0000e */	0x57,                           // push	 edi
/* 0000f */	0x8d, 0x46, 0x08,               // lea	 eax, DWORD PTR [esi+8]
/* 00012 */	0x50,                           // push	 eax
/* 00013 */	0xff, 0xb6, 0x1c, 0x02, 0x00, 
/*       */	0x00,                           // push	 DWORD PTR [esi+540]
/* 00019 */	0x8b, 0x06,                     // mov	 eax, DWORD PTR [esi]
/* 0001b */	0xff, 0xb6, 0x18, 0x02, 0x00, 
/*       */	0x00,                           // push	 DWORD PTR [esi+536]
/* 00021 */	0xff, 0xd0,                     // call	 eax
// 54   : 	if (data->OrigEIP) return (HANDLE)data->OrigEIP(data->EIPParams);
/* 00023 */	0x8b, 0x86, 0x20, 0x02, 0x00, 
/*       */	0x00,                           // mov	 eax, DWORD PTR [esi+544]
/* 00029 */	0x85, 0xc0,                     // test	 eax, eax
/* 0002b */	0x74, 0x0e,                     // je	 SHORT $LN2@APCProc
/* 0002d */	0xff, 0xb6, 0x24, 0x02, 0x00, 
/*       */	0x00,                           // push	 DWORD PTR [esi+548]
/* 00033 */	0xff, 0xd0,                     // call	 eax
/* 00035 */	0x5f,                           // pop	 edi
/* 00036 */	0x5e,                           // pop	 esi
// 56   : }
/* 00037 */	0x5d,                           // pop	 ebp
/* 00038 */	0xc2, 0x04, 0x00,               // ret	 4
/*LN2@APCProc:
 */	
// 55   : 	return data->ModuleHandle;
/* 0003b */	0x8b, 0x07,                     // mov	 eax, DWORD PTR [edi]
/* 0003d */	0x5f,                           // pop	 edi
/* 0003e */	0x5e,                           // pop	 esi
// 56   : }
/* 0003f */	0x5d,                           // pop	 ebp
/* 00040 */	0xc2, 0x04, 0x00                // ret	 4

};
const unsigned int APCProcx86Size = sizeof(APCProcx86);

BYTE PostProcProcx86[] = {
// 59   : {
/* 00000 */	0x56,                           // push	 esi
// 60   : 	// Workaround for compiler to not generate absolute addresses
// 61   : 	register PTHREAD_DATA pdata = (PTHREAD_DATA)((ULONG_PTR)1 << (sizeof(ULONG_PTR) * 8 - 1));
// 62   : 	PTHREAD_DATA data = (PTHREAD_DATA)pdata->fnLdrLoadDll;
/* 00001 */	0x8b, 0x35, 0x00, 0x00, 0x00, 
/*       */	0x80,                           // mov	 esi, DWORD PTR ds:-2147483648
// 63   : 
// 64   : 	data->fnLdrLoadDll(data->DllPath, data->Flags, &data->UnicodeString, &data->ModuleHandle);
/* 00007 */	0x8d, 0x86, 0x28, 0x02, 0x00, 
/*       */	0x00,                           // lea	 eax, DWORD PTR [esi+552]
/* 0000d */	0x50,                           // push	 eax
/* 0000e */	0x8d, 0x46, 0x08,               // lea	 eax, DWORD PTR [esi+8]
/* 00011 */	0x50,                           // push	 eax
/* 00012 */	0xff, 0xb6, 0x1c, 0x02, 0x00, 
/*       */	0x00,                           // push	 DWORD PTR [esi+540]
/* 00018 */	0x8b, 0x06,                     // mov	 eax, DWORD PTR [esi]
/* 0001a */	0xff, 0xb6, 0x18, 0x02, 0x00, 
/*       */	0x00,                           // push	 DWORD PTR [esi+536]
/* 00020 */	0xff, 0xd0,                     // call	 eax
// 65   : 	if (data->fnOrigPostProcessInit) data->fnOrigPostProcessInit();
/* 00022 */	0x8b, 0x46, 0x04,               // mov	 eax, DWORD PTR [esi+4]
/* 00025 */	0x5e,                           // pop	 esi
/* 00026 */	0x85, 0xc0,                     // test	 eax, eax
/* 00028 */	0x74, 0x02,                     // je	 SHORT $LN2@PostProcPr
/* 0002a */	0xff, 0xe0,                     // jmp	 eax
/*LN2@PostProcPr:
 */	
// 66   : }
/* 0002c */	0xc3                            // ret	 0

};
const unsigned int PostProcProcx86Size = sizeof(PostProcProcx86);

BYTE LdrpInitializeProcessProcx86[] = {
// 69   : {
/* 00000 */	0x55,                           // push	 ebp
/* 00001 */	0x8b, 0xec,                     // mov	 ebp, esp
/* 00003 */	0x56,                           // push	 esi
// 70   : 	NTSTATUS Status;
// 71   : 	// Workaround for compiler to not generate absolute addresses
// 72   : 	register PTHREAD_DATA pdata = (PTHREAD_DATA)((ULONG_PTR)1 << (sizeof(ULONG_PTR) * 8 - 1));
// 73   : 	PTHREAD_DATA data = (PTHREAD_DATA)pdata->fnLdrLoadDll;
/* 00004 */	0x8b, 0x35, 0x00, 0x00, 0x00, 
/*       */	0x80,                           // mov	 esi, DWORD PTR ds:-2147483648
/* 0000a */	0x57,                           // push	 edi
// 74   : 
// 75   : 	Status = data->fnLdrpInitializeProcess(Context, SystemDllBase);
/* 0000b */	0xff, 0x75, 0x0c,               // push	 DWORD PTR _SystemDllBase$[ebp]
/* 0000e */	0xff, 0x75, 0x08,               // push	 DWORD PTR _Context$[ebp]
/* 00011 */	0x8b, 0x46, 0x04,               // mov	 eax, DWORD PTR [esi+4]
/* 00014 */	0xff, 0xd0,                     // call	 eax
/* 00016 */	0x8b, 0xf8,                     // mov	 edi, eax
/* 00018 */	0x83, 0xc4, 0x08,               // add	 esp, 8
// 76   : 	if (NT_SUCCESS(Status))
/* 0001b */	0x85, 0xff,                     // test	 edi, edi
/* 0001d */	0x78, 0x1d,                     // js	 SHORT $LN2@LdrpInitia
// 77   : 		data->fnLdrLoadDll(data->DllPath, data->Flags, &data->UnicodeString, &data->ModuleHandle);
/* 0001f */	0x8b, 0x06,                     // mov	 eax, DWORD PTR [esi]
/* 00021 */	0x8d, 0x8e, 0x28, 0x02, 0x00, 
/*       */	0x00,                           // lea	 ecx, DWORD PTR [esi+552]
/* 00027 */	0x51,                           // push	 ecx
/* 00028 */	0x8d, 0x4e, 0x08,               // lea	 ecx, DWORD PTR [esi+8]
/* 0002b */	0x51,                           // push	 ecx
/* 0002c */	0xff, 0xb6, 0x1c, 0x02, 0x00, 
/*       */	0x00,                           // push	 DWORD PTR [esi+540]
/* 00032 */	0xff, 0xb6, 0x18, 0x02, 0x00, 
/*       */	0x00,                           // push	 DWORD PTR [esi+536]
/* 00038 */	0xff, 0xd0,                     // call	 eax
// 78   : 	return Status;
/* 0003a */	0x8b, 0xc7,                     // mov	 eax, edi
/*LN2@LdrpInitia:
 */	
/* 0003c */	0x5f,                           // pop	 edi
/* 0003d */	0x5e,                           // pop	 esi
// 79   : }
/* 0003e */	0x5d,                           // pop	 ebp
/* 0003f */	0xc3                            // ret	 0

};
const unsigned int LdrpInitializeProcessProcx86Size = sizeof(LdrpInitializeProcessProcx86);

